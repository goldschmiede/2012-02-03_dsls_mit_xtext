
/*
* generated by Xtext
*/
lexer grammar InternalMapDslLexer;

options {
	backtrack=true;
	memoize=true;
}

tokens {
	KEYWORD_1;
	KEYWORD_2;
	KEYWORD_3;
	KEYWORD_4;
	KEYWORD_5;
	KEYWORD_6;
	KEYWORD_7;
	KEYWORD_8;
	KEYWORD_9;
	RULE_ID;
	RULE_INT;
	RULE_STRING;
	RULE_ML_COMMENT;
	RULE_SL_COMMENT;
	RULE_WS;
	RULE_ANY_OTHER;
}

@header {
package de.goldschmiede.mapdsl.parser.antlr.lexer;

// Hack: Use our own Lexer superclass by means of import. 
// Currently there is no other way to specify the superclass for the lexer.
import org.eclipse.xtext.parser.antlr.Lexer;
}



SYNTHETIC_ALL_KEYWORDS :
	(FRAGMENT_KEYWORD_1)=> FRAGMENT_KEYWORD_1 {$type = KEYWORD_1; } |
	(FRAGMENT_KEYWORD_2)=> FRAGMENT_KEYWORD_2 {$type = KEYWORD_2; } |
	(FRAGMENT_KEYWORD_3)=> FRAGMENT_KEYWORD_3 {$type = KEYWORD_3; } |
	(FRAGMENT_KEYWORD_4)=> FRAGMENT_KEYWORD_4 {$type = KEYWORD_4; } |
	(FRAGMENT_KEYWORD_5)=> FRAGMENT_KEYWORD_5 {$type = KEYWORD_5; } |
	(FRAGMENT_KEYWORD_6)=> FRAGMENT_KEYWORD_6 {$type = KEYWORD_6; } |
	(FRAGMENT_KEYWORD_7)=> FRAGMENT_KEYWORD_7 {$type = KEYWORD_7; } |
	(FRAGMENT_KEYWORD_8)=> FRAGMENT_KEYWORD_8 {$type = KEYWORD_8; } |
	(FRAGMENT_KEYWORD_9)=> FRAGMENT_KEYWORD_9 {$type = KEYWORD_9; } |
	(FRAGMENT_RULE_ID)=> FRAGMENT_RULE_ID {$type = RULE_ID; } |
	(FRAGMENT_RULE_INT)=> FRAGMENT_RULE_INT {$type = RULE_INT; } |
	(FRAGMENT_RULE_STRING)=> FRAGMENT_RULE_STRING {$type = RULE_STRING; } |
	(FRAGMENT_RULE_ML_COMMENT)=> FRAGMENT_RULE_ML_COMMENT {$type = RULE_ML_COMMENT; } |
	(FRAGMENT_RULE_SL_COMMENT)=> FRAGMENT_RULE_SL_COMMENT {$type = RULE_SL_COMMENT; } |
	(FRAGMENT_RULE_WS)=> FRAGMENT_RULE_WS {$type = RULE_WS; } |
	(FRAGMENT_RULE_ANY_OTHER)=> FRAGMENT_RULE_ANY_OTHER {$type = RULE_ANY_OTHER; } ;

fragment FRAGMENT_KEYWORD_1 : '.';

fragment FRAGMENT_KEYWORD_2 : '{';

fragment FRAGMENT_KEYWORD_3 : '}';

fragment FRAGMENT_KEYWORD_4 : '.*';

fragment FRAGMENT_KEYWORD_5 : '=>';

fragment FRAGMENT_KEYWORD_6 : 'to';

fragment FRAGMENT_KEYWORD_7 : 'with';

fragment FRAGMENT_KEYWORD_8 : 'import';

fragment FRAGMENT_KEYWORD_9 : 'map BO';


// Rules duplicated to allow inter-rule references

fragment RULE_ID : FRAGMENT_RULE_ID;
fragment FRAGMENT_RULE_ID : '^'? ('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;

fragment RULE_INT : FRAGMENT_RULE_INT;
fragment FRAGMENT_RULE_INT : ('0'..'9')+;

fragment RULE_STRING : FRAGMENT_RULE_STRING;
fragment FRAGMENT_RULE_STRING : ('"' ('\\' ('b'|'t'|'n'|'f'|'r'|'u'|'"'|'\''|'\\')|~(('\\'|'"')))* '"'|'\'' ('\\' ('b'|'t'|'n'|'f'|'r'|'u'|'"'|'\''|'\\')|~(('\\'|'\'')))* '\'');

fragment RULE_ML_COMMENT : FRAGMENT_RULE_ML_COMMENT;
fragment FRAGMENT_RULE_ML_COMMENT : '/*' ( options {greedy=false;} : . )*'*/';

fragment RULE_SL_COMMENT : FRAGMENT_RULE_SL_COMMENT;
fragment FRAGMENT_RULE_SL_COMMENT : '//' ~(('\n'|'\r'))* ('\r'? '\n')?;

fragment RULE_WS : FRAGMENT_RULE_WS;
fragment FRAGMENT_RULE_WS : (' '|'\t'|'\r'|'\n')+;

fragment RULE_ANY_OTHER : FRAGMENT_RULE_ANY_OTHER;
fragment FRAGMENT_RULE_ANY_OTHER : .;



