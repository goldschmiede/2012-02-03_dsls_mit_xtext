/*
* generated by Xtext
*/

package de.goldschmiede.mapdsl.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;

import org.eclipse.xtext.common.services.TerminalsGrammarAccess;

@Singleton
public class MapDslGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class ModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Model");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cImportsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cImportsImportParserRuleCall_0_0 = (RuleCall)cImportsAssignment_0.eContents().get(0);
		private final Assignment cMapsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cMapsMappingParserRuleCall_1_0 = (RuleCall)cMapsAssignment_1.eContents().get(0);
		
		//Model:
		//	imports+=Import* maps+=Mapping*;
		public ParserRule getRule() { return rule; }

		//imports+=Import* maps+=Mapping*
		public Group getGroup() { return cGroup; }

		//imports+=Import*
		public Assignment getImportsAssignment_0() { return cImportsAssignment_0; }

		//Import
		public RuleCall getImportsImportParserRuleCall_0_0() { return cImportsImportParserRuleCall_0_0; }

		//maps+=Mapping*
		public Assignment getMapsAssignment_1() { return cMapsAssignment_1; }

		//Mapping
		public RuleCall getMapsMappingParserRuleCall_1_0() { return cMapsMappingParserRuleCall_1_0; }
	}

	public class MappingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Mapping");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cMapBOKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cSourceTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cSourceTypeBusinessObjectCrossReference_1_0 = (CrossReference)cSourceTypeAssignment_1.eContents().get(0);
		private final RuleCall cSourceTypeBusinessObjectQualifiedNameParserRuleCall_1_0_1 = (RuleCall)cSourceTypeBusinessObjectCrossReference_1_0.eContents().get(1);
		private final Keyword cToKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cTargetTypeAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final CrossReference cTargetTypeBusinessObjectCrossReference_3_0 = (CrossReference)cTargetTypeAssignment_3.eContents().get(0);
		private final RuleCall cTargetTypeBusinessObjectQualifiedNameParserRuleCall_3_0_1 = (RuleCall)cTargetTypeBusinessObjectCrossReference_3_0.eContents().get(1);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cWithKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_4_1 = (Keyword)cGroup_4.eContents().get(1);
		private final Assignment cAttributeMapAssignment_4_2 = (Assignment)cGroup_4.eContents().get(2);
		private final RuleCall cAttributeMapAttributeMapParserRuleCall_4_2_0 = (RuleCall)cAttributeMapAssignment_4_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4_3 = (Keyword)cGroup_4.eContents().get(3);
		
		//Mapping:
		//	"map BO" sourceType=[bodsl::BusinessObject|QualifiedName] "to" targetType=[bodsl::BusinessObject|QualifiedName]
		//	("with" "{" attributeMap+=AttributeMap+ "}")?;
		public ParserRule getRule() { return rule; }

		//"map BO" sourceType=[bodsl::BusinessObject|QualifiedName] "to" targetType=[bodsl::BusinessObject|QualifiedName] ("with"
		//"{" attributeMap+=AttributeMap+ "}")?
		public Group getGroup() { return cGroup; }

		//"map BO"
		public Keyword getMapBOKeyword_0() { return cMapBOKeyword_0; }

		//sourceType=[bodsl::BusinessObject|QualifiedName]
		public Assignment getSourceTypeAssignment_1() { return cSourceTypeAssignment_1; }

		//[bodsl::BusinessObject|QualifiedName]
		public CrossReference getSourceTypeBusinessObjectCrossReference_1_0() { return cSourceTypeBusinessObjectCrossReference_1_0; }

		//QualifiedName
		public RuleCall getSourceTypeBusinessObjectQualifiedNameParserRuleCall_1_0_1() { return cSourceTypeBusinessObjectQualifiedNameParserRuleCall_1_0_1; }

		//"to"
		public Keyword getToKeyword_2() { return cToKeyword_2; }

		//targetType=[bodsl::BusinessObject|QualifiedName]
		public Assignment getTargetTypeAssignment_3() { return cTargetTypeAssignment_3; }

		//[bodsl::BusinessObject|QualifiedName]
		public CrossReference getTargetTypeBusinessObjectCrossReference_3_0() { return cTargetTypeBusinessObjectCrossReference_3_0; }

		//QualifiedName
		public RuleCall getTargetTypeBusinessObjectQualifiedNameParserRuleCall_3_0_1() { return cTargetTypeBusinessObjectQualifiedNameParserRuleCall_3_0_1; }

		//("with" "{" attributeMap+=AttributeMap+ "}")?
		public Group getGroup_4() { return cGroup_4; }

		//"with"
		public Keyword getWithKeyword_4_0() { return cWithKeyword_4_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_4_1() { return cLeftCurlyBracketKeyword_4_1; }

		//attributeMap+=AttributeMap+
		public Assignment getAttributeMapAssignment_4_2() { return cAttributeMapAssignment_4_2; }

		//AttributeMap
		public RuleCall getAttributeMapAttributeMapParserRuleCall_4_2_0() { return cAttributeMapAttributeMapParserRuleCall_4_2_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_4_3() { return cRightCurlyBracketKeyword_4_3; }
	}

	public class AttributeMapElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AttributeMap");
		private final RuleCall cAttributeMoveMapParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//// Wir hier weitere Map Operationen definieren
		//AttributeMap:
		//	AttributeMoveMap;
		public ParserRule getRule() { return rule; }

		//AttributeMoveMap
		public RuleCall getAttributeMoveMapParserRuleCall() { return cAttributeMoveMapParserRuleCall; }
	}

	public class AttributeMoveMapElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AttributeMoveMap");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cSourceAttributeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cSourceAttributeAttributeCrossReference_0_0 = (CrossReference)cSourceAttributeAssignment_0.eContents().get(0);
		private final RuleCall cSourceAttributeAttributeQualifiedNameParserRuleCall_0_0_1 = (RuleCall)cSourceAttributeAttributeCrossReference_0_0.eContents().get(1);
		private final Keyword cEqualsSignGreaterThanSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTargetAttributeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cTargetAttributeAttributeCrossReference_2_0 = (CrossReference)cTargetAttributeAssignment_2.eContents().get(0);
		private final RuleCall cTargetAttributeAttributeQualifiedNameParserRuleCall_2_0_1 = (RuleCall)cTargetAttributeAttributeCrossReference_2_0.eContents().get(1);
		
		//AttributeMoveMap:
		//	sourceAttribute=[bodsl::Attribute|QualifiedName] "=>" targetAttribute=[bodsl::Attribute|QualifiedName];
		public ParserRule getRule() { return rule; }

		//sourceAttribute=[bodsl::Attribute|QualifiedName] "=>" targetAttribute=[bodsl::Attribute|QualifiedName]
		public Group getGroup() { return cGroup; }

		//sourceAttribute=[bodsl::Attribute|QualifiedName]
		public Assignment getSourceAttributeAssignment_0() { return cSourceAttributeAssignment_0; }

		//[bodsl::Attribute|QualifiedName]
		public CrossReference getSourceAttributeAttributeCrossReference_0_0() { return cSourceAttributeAttributeCrossReference_0_0; }

		//QualifiedName
		public RuleCall getSourceAttributeAttributeQualifiedNameParserRuleCall_0_0_1() { return cSourceAttributeAttributeQualifiedNameParserRuleCall_0_0_1; }

		//"=>"
		public Keyword getEqualsSignGreaterThanSignKeyword_1() { return cEqualsSignGreaterThanSignKeyword_1; }

		//targetAttribute=[bodsl::Attribute|QualifiedName]
		public Assignment getTargetAttributeAssignment_2() { return cTargetAttributeAssignment_2; }

		//[bodsl::Attribute|QualifiedName]
		public CrossReference getTargetAttributeAttributeCrossReference_2_0() { return cTargetAttributeAttributeCrossReference_2_0; }

		//QualifiedName
		public RuleCall getTargetAttributeAttributeQualifiedNameParserRuleCall_2_0_1() { return cTargetAttributeAttributeQualifiedNameParserRuleCall_2_0_1; }
	}

	public class QualifiedNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "QualifiedName");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cFullStopKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cIDTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		//QualifiedName:
		//	ID ("." ID)*;
		public ParserRule getRule() { return rule; }

		//ID ("." ID)*
		public Group getGroup() { return cGroup; }

		//ID
		public RuleCall getIDTerminalRuleCall_0() { return cIDTerminalRuleCall_0; }

		//("." ID)*
		public Group getGroup_1() { return cGroup_1; }

		//"."
		public Keyword getFullStopKeyword_1_0() { return cFullStopKeyword_1_0; }

		//ID
		public RuleCall getIDTerminalRuleCall_1_1() { return cIDTerminalRuleCall_1_1; }
	}

	public class QualifiedNameWithWildcardsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "QualifiedNameWithWildcards");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cQualifiedNameParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Keyword cFullStopAsteriskKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//QualifiedNameWithWildcards:
		//	QualifiedName ".*"?;
		public ParserRule getRule() { return rule; }

		//QualifiedName ".*"?
		public Group getGroup() { return cGroup; }

		//QualifiedName
		public RuleCall getQualifiedNameParserRuleCall_0() { return cQualifiedNameParserRuleCall_0; }

		//".*"?
		public Keyword getFullStopAsteriskKeyword_1() { return cFullStopAsteriskKeyword_1; }
	}

	public class ImportElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Import");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cImportKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cImportedNamespaceAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cImportedNamespaceQualifiedNameWithWildcardsParserRuleCall_1_0 = (RuleCall)cImportedNamespaceAssignment_1.eContents().get(0);
		
		//Import:
		//	"import" importedNamespace=QualifiedNameWithWildcards;
		public ParserRule getRule() { return rule; }

		//"import" importedNamespace=QualifiedNameWithWildcards
		public Group getGroup() { return cGroup; }

		//"import"
		public Keyword getImportKeyword_0() { return cImportKeyword_0; }

		//importedNamespace=QualifiedNameWithWildcards
		public Assignment getImportedNamespaceAssignment_1() { return cImportedNamespaceAssignment_1; }

		//QualifiedNameWithWildcards
		public RuleCall getImportedNamespaceQualifiedNameWithWildcardsParserRuleCall_1_0() { return cImportedNamespaceQualifiedNameWithWildcardsParserRuleCall_1_0; }
	}
	
	
	private ModelElements pModel;
	private MappingElements pMapping;
	private AttributeMapElements pAttributeMap;
	private AttributeMoveMapElements pAttributeMoveMap;
	private QualifiedNameElements pQualifiedName;
	private QualifiedNameWithWildcardsElements pQualifiedNameWithWildcards;
	private ImportElements pImport;
	
	private final GrammarProvider grammarProvider;

	private TerminalsGrammarAccess gaTerminals;

	@Inject
	public MapDslGrammarAccess(GrammarProvider grammarProvider,
		TerminalsGrammarAccess gaTerminals) {
		this.grammarProvider = grammarProvider;
		this.gaTerminals = gaTerminals;
	}
	
	public Grammar getGrammar() {	
		return grammarProvider.getGrammar(this);
	}
	

	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//Model:
	//	imports+=Import* maps+=Mapping*;
	public ModelElements getModelAccess() {
		return (pModel != null) ? pModel : (pModel = new ModelElements());
	}
	
	public ParserRule getModelRule() {
		return getModelAccess().getRule();
	}

	//Mapping:
	//	"map BO" sourceType=[bodsl::BusinessObject|QualifiedName] "to" targetType=[bodsl::BusinessObject|QualifiedName]
	//	("with" "{" attributeMap+=AttributeMap+ "}")?;
	public MappingElements getMappingAccess() {
		return (pMapping != null) ? pMapping : (pMapping = new MappingElements());
	}
	
	public ParserRule getMappingRule() {
		return getMappingAccess().getRule();
	}

	//// Wir hier weitere Map Operationen definieren
	//AttributeMap:
	//	AttributeMoveMap;
	public AttributeMapElements getAttributeMapAccess() {
		return (pAttributeMap != null) ? pAttributeMap : (pAttributeMap = new AttributeMapElements());
	}
	
	public ParserRule getAttributeMapRule() {
		return getAttributeMapAccess().getRule();
	}

	//AttributeMoveMap:
	//	sourceAttribute=[bodsl::Attribute|QualifiedName] "=>" targetAttribute=[bodsl::Attribute|QualifiedName];
	public AttributeMoveMapElements getAttributeMoveMapAccess() {
		return (pAttributeMoveMap != null) ? pAttributeMoveMap : (pAttributeMoveMap = new AttributeMoveMapElements());
	}
	
	public ParserRule getAttributeMoveMapRule() {
		return getAttributeMoveMapAccess().getRule();
	}

	//QualifiedName:
	//	ID ("." ID)*;
	public QualifiedNameElements getQualifiedNameAccess() {
		return (pQualifiedName != null) ? pQualifiedName : (pQualifiedName = new QualifiedNameElements());
	}
	
	public ParserRule getQualifiedNameRule() {
		return getQualifiedNameAccess().getRule();
	}

	//QualifiedNameWithWildcards:
	//	QualifiedName ".*"?;
	public QualifiedNameWithWildcardsElements getQualifiedNameWithWildcardsAccess() {
		return (pQualifiedNameWithWildcards != null) ? pQualifiedNameWithWildcards : (pQualifiedNameWithWildcards = new QualifiedNameWithWildcardsElements());
	}
	
	public ParserRule getQualifiedNameWithWildcardsRule() {
		return getQualifiedNameWithWildcardsAccess().getRule();
	}

	//Import:
	//	"import" importedNamespace=QualifiedNameWithWildcards;
	public ImportElements getImportAccess() {
		return (pImport != null) ? pImport : (pImport = new ImportElements());
	}
	
	public ParserRule getImportRule() {
		return getImportAccess().getRule();
	}

	//terminal ID:
	//	"^"? ("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	} 

	//terminal INT returns ecore::EInt:
	//	"0".."9"+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	} 

	//terminal STRING:
	//	"\"" ("\\" ("b" | "t" | "n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\""))* "\"" | "\'" ("\\" ("b" | "t" |
	//	"n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\'"))* "\'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	} 

	//terminal ML_COMMENT:
	//	"/ *"->"* /";
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	} 

	//terminal SL_COMMENT:
	//	"//" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	} 

	//terminal WS:
	//	(" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	} 
}
