/*
* generated by Xtext
*/

package de.goldschmiede.bodsl.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;

import org.eclipse.xtext.common.services.TerminalsGrammarAccess;

@Singleton
public class BusinessObjectDslGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class ModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Model");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cTypesAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cTypesSimpleTypeParserRuleCall_0_0 = (RuleCall)cTypesAssignment_0.eContents().get(0);
		private final Assignment cPackageAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cPackagePackageParserRuleCall_1_0 = (RuleCall)cPackageAssignment_1.eContents().get(0);
		
		//Model:
		//	types+=SimpleType+ | package=Package;
		public ParserRule getRule() { return rule; }

		//types+=SimpleType+ | package=Package
		public Alternatives getAlternatives() { return cAlternatives; }

		//types+=SimpleType+
		public Assignment getTypesAssignment_0() { return cTypesAssignment_0; }

		//SimpleType
		public RuleCall getTypesSimpleTypeParserRuleCall_0_0() { return cTypesSimpleTypeParserRuleCall_0_0; }

		//package=Package
		public Assignment getPackageAssignment_1() { return cPackageAssignment_1; }

		//Package
		public RuleCall getPackagePackageParserRuleCall_1_0() { return cPackagePackageParserRuleCall_1_0; }
	}

	public class PackageElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Package");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cPackageKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameQualifiedNameParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cImportsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cImportsImportParserRuleCall_2_0 = (RuleCall)cImportsAssignment_2.eContents().get(0);
		private final Assignment cTypeAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cTypeTypeParserRuleCall_3_0 = (RuleCall)cTypeAssignment_3.eContents().get(0);
		
		//Package:
		//	"package" name=QualifiedName imports+=Import* type=Type;
		public ParserRule getRule() { return rule; }

		//"package" name=QualifiedName imports+=Import* type=Type
		public Group getGroup() { return cGroup; }

		//"package"
		public Keyword getPackageKeyword_0() { return cPackageKeyword_0; }

		//name=QualifiedName
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//QualifiedName
		public RuleCall getNameQualifiedNameParserRuleCall_1_0() { return cNameQualifiedNameParserRuleCall_1_0; }

		//imports+=Import*
		public Assignment getImportsAssignment_2() { return cImportsAssignment_2; }

		//Import
		public RuleCall getImportsImportParserRuleCall_2_0() { return cImportsImportParserRuleCall_2_0; }

		//type=Type
		public Assignment getTypeAssignment_3() { return cTypeAssignment_3; }

		//Type
		public RuleCall getTypeTypeParserRuleCall_3_0() { return cTypeTypeParserRuleCall_3_0; }
	}

	public class ImportElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Import");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cImportKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cImportedNamespaceAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cImportedNamespaceQualifiedNameWithWildcardsParserRuleCall_1_0 = (RuleCall)cImportedNamespaceAssignment_1.eContents().get(0);
		
		/// *
		// * Importe verwenden die Konvention, dass ein Modellobjekt mit dem Attribut "importedNamespace" einen zu
		// * importierenden Namespace deklariert. Zum Auflösen der Importe wird ein ScopeProvider verwendet, der den Scope
		// * des Linkers bei der Suche nach passenden Elementen, die eine Referenz erfüllen, entsprechend erweitert.
		// * Damit das funktioniert, muss im Script GeneratoBusinessObjectDsl.mwe2 das Fragment <br/><br/>
		// * 
		// * 			<code>fragment = scoping.ImportNamespacesScopingFragment {}</code>
		// * 
		// * <br/><br/>
		// * definiert sein. Die ParserRule muss nicht zwingend "Import" heißen. S.a. Scoping in der Xtext-Hilfe.
		// * / Import:
		//	"import" importedNamespace=QualifiedNameWithWildcards;
		public ParserRule getRule() { return rule; }

		//"import" importedNamespace=QualifiedNameWithWildcards
		public Group getGroup() { return cGroup; }

		//"import"
		public Keyword getImportKeyword_0() { return cImportKeyword_0; }

		//importedNamespace=QualifiedNameWithWildcards
		public Assignment getImportedNamespaceAssignment_1() { return cImportedNamespaceAssignment_1; }

		//QualifiedNameWithWildcards
		public RuleCall getImportedNamespaceQualifiedNameWithWildcardsParserRuleCall_1_0() { return cImportedNamespaceQualifiedNameWithWildcardsParserRuleCall_1_0; }
	}

	public class BusinessObjectElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BusinessObject");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cBusinessObjectKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cAttributesAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cAttributesAttributeParserRuleCall_3_0 = (RuleCall)cAttributesAssignment_3.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//BusinessObject:
		//	"businessObject" name=ID "{" attributes+=Attribute* "}";
		public ParserRule getRule() { return rule; }

		//"businessObject" name=ID "{" attributes+=Attribute* "}"
		public Group getGroup() { return cGroup; }

		//"businessObject"
		public Keyword getBusinessObjectKeyword_0() { return cBusinessObjectKeyword_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }

		//attributes+=Attribute*
		public Assignment getAttributesAssignment_3() { return cAttributesAssignment_3; }

		//Attribute
		public RuleCall getAttributesAttributeParserRuleCall_3_0() { return cAttributesAttributeParserRuleCall_3_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}

	public class EnumerationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Enumeration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cEnumKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cLiteralsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cLiteralsEnumLiteralParserRuleCall_3_0 = (RuleCall)cLiteralsAssignment_3.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//Enumeration:
		//	"enum" name=ID "{" literals+=EnumLiteral+ "}";
		public ParserRule getRule() { return rule; }

		//"enum" name=ID "{" literals+=EnumLiteral+ "}"
		public Group getGroup() { return cGroup; }

		//"enum"
		public Keyword getEnumKeyword_0() { return cEnumKeyword_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }

		//literals+=EnumLiteral+
		public Assignment getLiteralsAssignment_3() { return cLiteralsAssignment_3; }

		//EnumLiteral
		public RuleCall getLiteralsEnumLiteralParserRuleCall_3_0() { return cLiteralsEnumLiteralParserRuleCall_3_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}

	public class EnumLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EnumLiteral");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//EnumLiteral:
		//	name=ID;
		public ParserRule getRule() { return rule; }

		//name=ID
		public Assignment getNameAssignment() { return cNameAssignment; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_0() { return cNameIDTerminalRuleCall_0; }
	}

	public class AttributeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Attribute");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cTypeTypeCrossReference_2_0 = (CrossReference)cTypeAssignment_2.eContents().get(0);
		private final RuleCall cTypeTypeQualifiedNameParserRuleCall_2_0_1 = (RuleCall)cTypeTypeCrossReference_2_0.eContents().get(1);
		
		//Attribute:
		//	name=ID ":" type=[Type|QualifiedName];
		public ParserRule getRule() { return rule; }

		//name=ID ":" type=[Type|QualifiedName]
		public Group getGroup() { return cGroup; }

		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }

		//":"
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }

		//type=[Type|QualifiedName]
		public Assignment getTypeAssignment_2() { return cTypeAssignment_2; }

		//[Type|QualifiedName]
		public CrossReference getTypeTypeCrossReference_2_0() { return cTypeTypeCrossReference_2_0; }

		//QualifiedName
		public RuleCall getTypeTypeQualifiedNameParserRuleCall_2_0_1() { return cTypeTypeQualifiedNameParserRuleCall_2_0_1; }
	}

	public class TypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Type");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cBusinessObjectParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cEnumerationParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cSimpleTypeParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		/// * Eine Vererbungshierarchie vom Metamodellobjekten. <code>Type</code> ist der Basistyp. * / Type:
		//	BusinessObject | Enumeration | SimpleType;
		public ParserRule getRule() { return rule; }

		//BusinessObject | Enumeration | SimpleType
		public Alternatives getAlternatives() { return cAlternatives; }

		//BusinessObject
		public RuleCall getBusinessObjectParserRuleCall_0() { return cBusinessObjectParserRuleCall_0; }

		//Enumeration
		public RuleCall getEnumerationParserRuleCall_1() { return cEnumerationParserRuleCall_1; }

		//SimpleType
		public RuleCall getSimpleTypeParserRuleCall_2() { return cSimpleTypeParserRuleCall_2; }
	}

	public class SimpleTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SimpleType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cTypeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		//SimpleType:
		//	"type" name=ID;
		public ParserRule getRule() { return rule; }

		//"type" name=ID
		public Group getGroup() { return cGroup; }

		//"type"
		public Keyword getTypeKeyword_0() { return cTypeKeyword_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
	}

	public class QualifiedNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "QualifiedName");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cFullStopKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cIDTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		//QualifiedName:
		//	ID ("." ID)*;
		public ParserRule getRule() { return rule; }

		//ID ("." ID)*
		public Group getGroup() { return cGroup; }

		//ID
		public RuleCall getIDTerminalRuleCall_0() { return cIDTerminalRuleCall_0; }

		//("." ID)*
		public Group getGroup_1() { return cGroup_1; }

		//"."
		public Keyword getFullStopKeyword_1_0() { return cFullStopKeyword_1_0; }

		//ID
		public RuleCall getIDTerminalRuleCall_1_1() { return cIDTerminalRuleCall_1_1; }
	}

	public class QualifiedNameWithWildcardsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "QualifiedNameWithWildcards");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cQualifiedNameParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Keyword cFullStopAsteriskKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//QualifiedNameWithWildcards:
		//	QualifiedName ".*"?;
		public ParserRule getRule() { return rule; }

		//QualifiedName ".*"?
		public Group getGroup() { return cGroup; }

		//QualifiedName
		public RuleCall getQualifiedNameParserRuleCall_0() { return cQualifiedNameParserRuleCall_0; }

		//".*"?
		public Keyword getFullStopAsteriskKeyword_1() { return cFullStopAsteriskKeyword_1; }
	}
	
	
	private ModelElements pModel;
	private PackageElements pPackage;
	private ImportElements pImport;
	private BusinessObjectElements pBusinessObject;
	private EnumerationElements pEnumeration;
	private EnumLiteralElements pEnumLiteral;
	private AttributeElements pAttribute;
	private TypeElements pType;
	private SimpleTypeElements pSimpleType;
	private QualifiedNameElements pQualifiedName;
	private QualifiedNameWithWildcardsElements pQualifiedNameWithWildcards;
	
	private final GrammarProvider grammarProvider;

	private TerminalsGrammarAccess gaTerminals;

	@Inject
	public BusinessObjectDslGrammarAccess(GrammarProvider grammarProvider,
		TerminalsGrammarAccess gaTerminals) {
		this.grammarProvider = grammarProvider;
		this.gaTerminals = gaTerminals;
	}
	
	public Grammar getGrammar() {	
		return grammarProvider.getGrammar(this);
	}
	

	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//Model:
	//	types+=SimpleType+ | package=Package;
	public ModelElements getModelAccess() {
		return (pModel != null) ? pModel : (pModel = new ModelElements());
	}
	
	public ParserRule getModelRule() {
		return getModelAccess().getRule();
	}

	//Package:
	//	"package" name=QualifiedName imports+=Import* type=Type;
	public PackageElements getPackageAccess() {
		return (pPackage != null) ? pPackage : (pPackage = new PackageElements());
	}
	
	public ParserRule getPackageRule() {
		return getPackageAccess().getRule();
	}

	/// *
	// * Importe verwenden die Konvention, dass ein Modellobjekt mit dem Attribut "importedNamespace" einen zu
	// * importierenden Namespace deklariert. Zum Auflösen der Importe wird ein ScopeProvider verwendet, der den Scope
	// * des Linkers bei der Suche nach passenden Elementen, die eine Referenz erfüllen, entsprechend erweitert.
	// * Damit das funktioniert, muss im Script GeneratoBusinessObjectDsl.mwe2 das Fragment <br/><br/>
	// * 
	// * 			<code>fragment = scoping.ImportNamespacesScopingFragment {}</code>
	// * 
	// * <br/><br/>
	// * definiert sein. Die ParserRule muss nicht zwingend "Import" heißen. S.a. Scoping in der Xtext-Hilfe.
	// * / Import:
	//	"import" importedNamespace=QualifiedNameWithWildcards;
	public ImportElements getImportAccess() {
		return (pImport != null) ? pImport : (pImport = new ImportElements());
	}
	
	public ParserRule getImportRule() {
		return getImportAccess().getRule();
	}

	//BusinessObject:
	//	"businessObject" name=ID "{" attributes+=Attribute* "}";
	public BusinessObjectElements getBusinessObjectAccess() {
		return (pBusinessObject != null) ? pBusinessObject : (pBusinessObject = new BusinessObjectElements());
	}
	
	public ParserRule getBusinessObjectRule() {
		return getBusinessObjectAccess().getRule();
	}

	//Enumeration:
	//	"enum" name=ID "{" literals+=EnumLiteral+ "}";
	public EnumerationElements getEnumerationAccess() {
		return (pEnumeration != null) ? pEnumeration : (pEnumeration = new EnumerationElements());
	}
	
	public ParserRule getEnumerationRule() {
		return getEnumerationAccess().getRule();
	}

	//EnumLiteral:
	//	name=ID;
	public EnumLiteralElements getEnumLiteralAccess() {
		return (pEnumLiteral != null) ? pEnumLiteral : (pEnumLiteral = new EnumLiteralElements());
	}
	
	public ParserRule getEnumLiteralRule() {
		return getEnumLiteralAccess().getRule();
	}

	//Attribute:
	//	name=ID ":" type=[Type|QualifiedName];
	public AttributeElements getAttributeAccess() {
		return (pAttribute != null) ? pAttribute : (pAttribute = new AttributeElements());
	}
	
	public ParserRule getAttributeRule() {
		return getAttributeAccess().getRule();
	}

	/// * Eine Vererbungshierarchie vom Metamodellobjekten. <code>Type</code> ist der Basistyp. * / Type:
	//	BusinessObject | Enumeration | SimpleType;
	public TypeElements getTypeAccess() {
		return (pType != null) ? pType : (pType = new TypeElements());
	}
	
	public ParserRule getTypeRule() {
		return getTypeAccess().getRule();
	}

	//SimpleType:
	//	"type" name=ID;
	public SimpleTypeElements getSimpleTypeAccess() {
		return (pSimpleType != null) ? pSimpleType : (pSimpleType = new SimpleTypeElements());
	}
	
	public ParserRule getSimpleTypeRule() {
		return getSimpleTypeAccess().getRule();
	}

	//QualifiedName:
	//	ID ("." ID)*;
	public QualifiedNameElements getQualifiedNameAccess() {
		return (pQualifiedName != null) ? pQualifiedName : (pQualifiedName = new QualifiedNameElements());
	}
	
	public ParserRule getQualifiedNameRule() {
		return getQualifiedNameAccess().getRule();
	}

	//QualifiedNameWithWildcards:
	//	QualifiedName ".*"?;
	public QualifiedNameWithWildcardsElements getQualifiedNameWithWildcardsAccess() {
		return (pQualifiedNameWithWildcards != null) ? pQualifiedNameWithWildcards : (pQualifiedNameWithWildcards = new QualifiedNameWithWildcardsElements());
	}
	
	public ParserRule getQualifiedNameWithWildcardsRule() {
		return getQualifiedNameWithWildcardsAccess().getRule();
	}

	//terminal ID:
	//	"^"? ("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	} 

	//terminal INT returns ecore::EInt:
	//	"0".."9"+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	} 

	//terminal STRING:
	//	"\"" ("\\" ("b" | "t" | "n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\""))* "\"" | "\'" ("\\" ("b" | "t" |
	//	"n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\'"))* "\'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	} 

	//terminal ML_COMMENT:
	//	"/ *"->"* /";
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	} 

	//terminal SL_COMMENT:
	//	"//" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	} 

	//terminal WS:
	//	(" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	} 
}
